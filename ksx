#!/usr/bin/env python

import sys
from os.path import dirname, realpath, join, exists
from re import match, search

global import_dir, local_bin_subdir

local_bin_subdir = "bin"

import_dir = dirname(realpath(__file__))
if match(r'bin$', import_dir) or match(r'bin/$', import_dir):
    import_dir = dirname(import_dir) # up one level, if "bin" at the end

sys.path.append(import_dir)

from string import Template # native templating
import apis
import os, stat, subprocess

import http.client, json
from urllib.parse import urlparse


def http_get(domain, path, verbose=False):
    is_got = False
    conn = http.client.HTTPSConnection(domain)
    conn.request("GET", path)
    r1 = conn.getresponse()

    if verbose:
        print("Downloading {}{}".format(domain, path))

    for i in range(10):
        if r1.status == 302 or r1.status == 301:
            redir = urlparse(r1.headers['Location'])
            if verbose:
                print("Redirect to {}{}".format(redir.netloc, redir.path))
            conn = http.client.HTTPSConnection(redir.netloc)
            conn.request("GET", redir.path)
            r1 = conn.getresponse()
        elif r1.status > 399:
            raise Exception("Error {} occured, while downloading {}/{}".format(r1.status, domain, path))
        else:
            is_got = True
            break

    if not is_got:
        raise Exception("Can not get {}{}. Seems, infinite redirection loop".format(domain, path))

    return r1.read()


def install_kubectl(kubepath=None, kubeversion=None, verbose=False):
    api_config = apis.GLOBAL_API_CONFIG

    if not kubepath:
        kubepath = join(api_config["binpath"], 'kubectl')

    if not kubeversion:
        kubeversion = http_get("dl.k8s.io", "/release/stable.txt", verbose).decode('utf-8')

    if not match(r'^v', kubeversion):
        kubeversion = 'v' + kubeversion

    if verbose:
        print("kubectl version is {}".format(kubeversion))

    kubeversion_local = None
    if exists(kubepath):
        try:
            cmd = "{} version --client=true -o json".format(kubepath)
            kubeversion_local = json.loads(subprocess.check_output(cmd, shell=True))['clientVersion']['gitVersion']
        except FileExistsError:
            pass

    if kubeversion_local != kubeversion:
        kctl_bin = http_get("dl.k8s.io", "/release/{}/bin/linux/amd64/kubectl".format(kubeversion))

        if verbose:
            print("Saving kubectl to {}".format(kubepath))
        with open(kubepath, "wb") as f:
            f.write(kctl_bin)

        ## chmod +x
        st = os.stat(kubepath)
        os.chmod(kubepath, st.st_mode | stat.S_IEXEC)


def compile(verbose=False):
    global local_bin_subdir
    # get "werbs" template
    api_config = apis.GLOBAL_API_CONFIG

    for i in api_config["conf"]:
        result = ""
        dist_bindir = join(import_dir, local_bin_subdir)
        resfile = join(dist_bindir, i["filename"])
        configfile = join(api_config["configpath"], api_config["configname"])

        os.makedirs(dist_bindir, exist_ok = True)

        # reset file content
        with open(resfile, 'w') as f:
            f.write("")

        ## write base templates
        for t in api_config["base_templates"]:
            with open(t, 'r') as f:
                src = f.read()
            with open(resfile, 'a') as f:
                f.write(src)

        # write main template
        with open(i['template'], 'r') as f:
            i["config"] = configfile
            src = Template(f.read())
            result = src.substitute(i)
        with open(resfile, 'a') as f:
            f.write(result)

        # chmod +x
        st = os.stat(resfile)
        os.chmod(resfile, st.st_mode | stat.S_IEXEC)
        if verbose:
            print("file {} generated".format(i["filename"]))
            

def install(verbose=False):
    api_config = apis.GLOBAL_API_CONFIG
    dist_bindir = join(import_dir, local_bin_subdir)

    for i in api_config["conf"]:
        origpath = join(dist_bindir, i["filename"])
        copypath = join(api_config["binpath"], i["filename"])
        orig = open(origpath, "r")
        copy = open(copypath, "wt")
        line = orig.read()
        copy.write(str(line))
        orig.close()
        copy.close()
        ## chmod +x
        st = os.stat(copypath)
        os.chmod(copypath, st.st_mode | stat.S_IEXEC)
        if verbose:
            print("file {} installed".format(copypath))


def uninstall(verbose=False):
    api_config = apis.GLOBAL_API_CONFIG
    dist_bindir = join(import_dir, local_bin_subdir)

    for i in api_config["conf"]:
        path = join(api_config["binpath"], i["filename"])
        os.remove(path) 
        if verbose:
            print("file {} removed".format(path))


def add_to_path(verbose=False):
    api_config = apis.GLOBAL_API_CONFIG
    path=api_config["binpath"]

    if not search(path, os.environ.get('PATH')):
        profile_path = join(os.environ['HOME'], ".profile")
        ## try bashrc
        if not exists(profile_path):
            profile_path = join(os.environ['HOME'], ".bashrc")
            ## try zshrc
        if not exists(profile_path):
            profile_path = join(os.environ['HOME'], ".zshrc")
            ## give up
        if not exists(profile_path):
            raise FileNotFoundError("Can not find shell profile file to add ksx to PATH")
    
        with open(profile_path, 'a') as f:
            f.write("export PATH={}:$PATH\n".format(path))
        if verbose:
            print("Add {} to PATH".format(path))
    else:
        if verbose:
            print("{} already exist in PATH. Skip".format(path))


def genconfig (kubepath=None, shell='/bin/bash', verbose=False):
    api_config = apis.GLOBAL_API_CONFIG

    # make config directory
    os.makedirs(api_config["configpath"], exist_ok = True)

    configpath = join(api_config["configpath"], api_config["configname"])
    ## set default kubepath
    if not kubepath:
        kubepath = join(api_config["binpath"], 'kubectl')

    ## setup config file
    config = {
        "cmd": kubepath,
        "shell": shell
    }

    json_object = json.dumps(config, indent = 2)

    if verbose:
        print("Generating configfile")
    with open(configpath, "w") as outfile:
        outfile.write(json_object)


compile(True)
install(True)
# uninstall(True)

# add_to_path(True)
# genconfig(verbose=True)
# install_kubectl(verbose=True)
