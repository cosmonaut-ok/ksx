#!/usr/bin/env python3

import os, sys
sys.path.append(os.path.dirname(os.path.dirname(os.path.realpath(__file__))))

from os.path import join, realpath, dirname, exists
from os import makedirs

import stat
import subprocess
import argparse
import re

from werbs import Werbs

import http.client, json
from urllib.parse import urlparse

from string import Template # native templating

import apis

global am_i_bin, global_api_config

am_i_bin = False

def http_get(domain, path, verbose=False):
    is_got = False
    conn = http.client.HTTPSConnection(domain)
    conn.request("GET", path)
    r1 = conn.getresponse()

    if verbose:
        print("Downloading {}{}".format(domain, path))

    for i in range(10):
        if r1.status == 302 or r1.status == 301:
            redir = urlparse(r1.headers['Location'])
            if verbose:
                print("Redirect to {}{}".format(redir.netloc, redir.path))
            conn = http.client.HTTPSConnection(redir.netloc)
            conn.request("GET", redir.path)
            r1 = conn.getresponse()
        elif r1.status > 399:
            raise Exception("Error {} occured, while downloading {}/{}".format(r1.status, domain, path))
        else:
            is_got = True
            break

    if not is_got:
        raise Exception("Can not get {}{}. Seems, infinite redirection loop".format(domain, path))

    return r1.read()


def install_kubectl(kubepath, kubeversion=None, verbose=False):
    if not kubeversion:
        kubeversion = http_get("dl.k8s.io", "/release/stable.txt", verbose).decode('utf-8')

    if not re.match(r'^v', kubeversion):
        kubeversion = 'v' + kubeversion

    if verbose:
        print("kubectl version is {}".format(kubeversion))

    kubeversion_local = None
    if exists(kubepath):
        try:
            cmd = "{} version --client=true -o json".format(kubepath)
            kubeversion_local = json.loads(subprocess.check_output(cmd, shell=True))['clientVersion']['gitVersion']
        except FileExistsError:
            pass

    if kubeversion_local != kubeversion:
        kctl_bin = http_get("dl.k8s.io", "/release/{}/bin/linux/amd64/kubectl".format(kubeversion))

        if verbose:
            print("Saving kubectl to {}".format(kubepath))
        with open(kubepath, "wb") as f:
            f.write(kctl_bin)

        ## chmod +x
        st = os.stat(kubepath)
        os.chmod(kubepath, st.st_mode | stat.S_IEXEC)


def genconfig (kubeconfig, kubepath, shell='/bin/bash', verbose=False):
    ## setup config file
    config = {
        "cmd": kubepath,
        "shell": shell
    }

    json_object = json.dumps(config, indent = 2)

    if verbose:
        print("Generating configfile")
    with open(kubeconfig, "w") as outfile:
        outfile.write(json_object)


def genfiles (verbose=False):

    ## create directory
    try:
        os.makedirs("bin")
    except:
        pass

    api_config = apis.GLOBAL_API_CONFIG

    for i in api_config:
        result = ""
        with open('kstemplate', 'r') as f:
            src = Template(f.read())
            result = src.substitute(i)

        # write file
        fname = join("bin", i["filename"])
        with open(fname, 'w') as f:
            f.write(result)
        ## chmod +x
        st = os.stat(fname)
        os.chmod(fname, st.st_mode | stat.S_IEXEC)
        if verbose:
            print("file {} generated".format(i["filename"]))
        
    ## copy ksc
    f = open('ksc',"r")
    copyname = join("bin", "ksc")
    copy = open(copyname, "wt")
    line = f.read()
    copy.write(str(line))
    f.close()
    copy.close()
    ## chmod +x
    st = os.stat(copyname)
    os.chmod(copyname, st.st_mode | stat.S_IEXEC)
    if verbose:
        print("file {} copied".format(copyname))

    ## copy ksn
    f = open('ksn',"r")
    copyname = join("bin", "ksn")
    copy = open(copyname, "wt")
    line = f.read()
    copy.write(str(line))
    f.close()
    copy.close()
    ## chmod +x
    st = os.stat(copyname)
    os.chmod(copyname, st.st_mode | stat.S_IEXEC)
    if verbose:
        print("file {} copied".format(copyname))

    ## copy ksx
    f = open('ksx',"r")
    copyname = join("bin", "ksx")
    copy = open(copyname, "wt")
    line = f.read()
    copy.write(str(line))
    f.close()
    copy.close()
    ## chmod +x
    st = os.stat(copyname)
    os.chmod(copyname, st.st_mode | stat.S_IEXEC)
    if verbose:
        print("file {} copied".format(copyname))


def init(kubeversion=None, kubeshell='/bin/bash', no_genconfig=False, genexecs=False, verbose=False):
    kctl_path=join(dirname(dirname(realpath(__file__))), 'kubectl')
    config_path=join(dirname(dirname(realpath(__file__))), 'ksx.json')

    install_kubectl(kctl_path, kubeversion, verbose)

    if not no_genconfig:
        genconfig(config_path, kctl_path, kubeshell, verbose)

    if not am_i_bin and genexecs:
        genfiles(verbose)


def add_to_path(verbose=False):
    profile_path = join(os.environ['HOME'], ".profile")
    ## try bashrc
    if not exists(profile_path):
        profile_path = join(os.environ['HOME'], ".bashrc")
    ## try zshrc
    if not exists(profile_path):
        profile_path = join(os.environ['HOME'], ".zshrc")
    ## give up
    if not exists(profile_path):
        raise FileNotFoundError("Can not find shell profile file to add ksx to PATH")
    
    self_dirname = join(dirname(realpath(__file__)), "bin")
    if verbose:
        print("Adding {} to PATH".format(self_dirname))
    with open(profile_path, 'a') as f:
        f.write("export PATH={}:$PATH\n".format(self_dirname))


def main ():
    parser = argparse.ArgumentParser(description='ksx is a collection of kubernetes management tools. This script is for service operations')

    parser.add_argument('-i', '--info',
                        action='store_true',
                        dest='info',
                        help='Show info about ksx tools'
                        )

    parser.add_argument('--init',
                        action='store_true',
                        dest='init',
                        help='Preform initial configuration (e.g. install embedded kubectl, generate config etc)'
                        )

    parser.add_argument('--add-to-path',
                        action='store_true',
                        dest='add_to_path',
                        help='Preform initial configuration (e.g. install embedded kubectl, generate config etc)'
                        )

    if not am_i_bin:
        parser.add_argument('--genexecs',
                            action='store_true',
                            dest='genexecs',
                            help='Generate executable utils'
                            )

    parser.add_argument('-v', '--verbose',
                        action='count',
                        default=0)

    parser.add_argument('--version',
                        action='store_true',
                        help='Print ksx version and exit',
                        default=None
                        )

    parser.add_argument('--kubectl-version',
                        dest='kubeversion',
                        type=str,
                        help='Install specified kubectl version (default: current stable)',
                        default=None
                        )

    parser.add_argument('--no-genconfig',
                        action='store_true',
                        dest='nogenconfig',
                        help='Show info about ksx tools'
                        )

    parser.add_argument('--kubectl-shell',
                        dest='kubeshell',
                        type=str,
                        help='Use specific shell as default to enter the pod (default: /bin/bash)',
                        default='/bin/bash'
                        )

    args = parser.parse_args()

    genexecs = False
    try:
        genexecs = args.genexecs
    except:
        pass

    if args.info:
        show_extended_help()
    elif args.init or genexecs:
        init(args.kubeversion, args.kubeshell, args.nogenconfig, genexecs, args.verbose)
    elif args.version:
        werbs = Werbs()
        werbs.print_version()
    elif args.add_to_path:
        add_to_path(args.verbose)
    else:
        parser.print_help(sys.stderr)


def show_extended_help ():
    print('''ksX is a collection of tools for kubernetes, wrapped over standard
kubernetes control tool `kubectl`.  The motivation of ksX is to
develop more `laconic` kubectl, that also follows unix way principle:
`Make each program do one thing well` and principle of least
astonishment. So, each ksX's tool is very simple and bound to some
kubernetes resouce, like `pod`, `ingress` etc. The list of ksX tools:
''')

    for i in apis.GLOBAL_API_CONFIG:
        print("{}\t- {}".format(i["filename"], i["description"]))

# OPTIONS (common for all tools):
#   one optional positional argument
#   with default action (depends on tool):
#   -h, --help\t\t\t\tshow help message and exit
#   -l, --list\t\t\t\tlist of objects of selected type
#   -d <OBJECT>, --describe <OBJECT>\tdescribe object
#   -e <OBJECT>, --edit <OBJECT>\t\tedit object
#   --del <OBJECT>, --delete <OBJECT>\tdelete object (deprecated), see --remove
#   --scale <OBJECT>\t\t\tscale object. Use only with --rpl, --replicas
#   --rpl <NUMBER>, --replicas <NUMBER>\tNumber of replicas to scale
#   --r, <OBJECT>, --remove <OBJECT>\tremove (delete) object
#   --wat\t\t\t\t\tManual about object operations (like kubectl explain)
#   -o <OUTPUT>, --output <OUTPUT>\toutput format, based on original kubectl types:
# \t\t\t\t\t json|yaml|wide|custom-
# \t\t\t\t\t columns=...|custom-columns-file=...|go-
# \t\t\t\t\t template=...|go-template-
# \t\t\t\t\t file=...|jsonpath=...|jsonpath-file=...]
#   -t, --trace\t\t\t\tprint real kubectl commands
#   -v, --version\t\t\t\tshow version of application
#   --labels LABELS\t\t\tUse label to filter out objects




if __name__ == "__main__":
    main()
