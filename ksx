#!/usr/bin/env python

import sys, os, stat, subprocess, http.client, argparse, re
from json import loads, dumps
from urllib.parse import urlparse
from os.path import dirname, realpath, join, exists
from re import match, search
from string import Template # native templating

global import_dir, local_bin_subdir, is_compiled

is_compiled = False 

local_bin_subdir = "bin"

import_dir = dirname(realpath(__file__))
if match(r'bin$', import_dir) or match(r'bin/$', import_dir):
    import_dir = dirname(import_dir) # up one level, if "bin" at the end

sys.path.append(import_dir)

from apis import GLOBAL_API_CONFIG
# import os, stat, subprocess
# import http.client, json
# from urllib.parse import urlparse

def chmod_x(path, verbose=False):
    st = os.stat(path)
    os.chmod(path, st.st_mode | stat.S_IEXEC)
    if verbose:
        print("file {} generated".format(path))

def http_get(domain, path, verbose=False):
    is_got = False
    conn = http.client.HTTPSConnection(domain)
    conn.request("GET", path)
    r1 = conn.getresponse()

    if verbose:
        print("Downloading {}{}".format(domain, path))

    for i in range(10):
        if r1.status == 302 or r1.status == 301:
            redir = urlparse(r1.headers['Location'])
            if verbose:
                print("Redirect to {}{}".format(redir.netloc, redir.path))
            conn = http.client.HTTPSConnection(redir.netloc)
            conn.request("GET", redir.path)
            r1 = conn.getresponse()
        elif r1.status > 399:
            raise Exception("Error {} occured, while downloading {}/{}".format(r1.status, domain, path))
        else:
            is_got = True
            break

    if not is_got:
        raise Exception("Can not get {}{}. Seems, infinite redirection loop".format(domain, path))

    return r1.read()


def install_kubectl(kubepath=None, kubeversion=None, verbose=False):
    api_config = GLOBAL_API_CONFIG

    if not kubepath:
        kubepath = join(api_config["binpath"], 'kubectl')
    kubepath = os.path.expanduser(kubepath)

    if not kubeversion:
        kubeversion = http_get("dl.k8s.io", "/release/stable.txt", verbose).decode('utf-8')

    if not match(r'^v', kubeversion):
        kubeversion = 'v' + kubeversion

    if verbose:
        print("kubectl version is {}".format(kubeversion))

    kubeversion_local = None
    if exists(kubepath):
        try:
            cmd = "{} version --client=true -o json".format(kubepath)
            kubeversion_local = loads(subprocess.check_output(cmd, shell=True))['clientVersion']['gitVersion']
        except FileExistsError:
            pass

    if kubeversion_local != kubeversion:
        if verbose:
            print("Saving kubectl to {}".format(kubepath))
        kctl_bin = http_get("dl.k8s.io", "/release/{}/bin/linux/amd64/kubectl".format(kubeversion))
        with open(kubepath, "wb") as f:
            f.write(kctl_bin)
        chmod_x(kubepath)


def compile(verbose=False):
    global local_bin_subdir
    # get "werbs" template
    api_config = GLOBAL_API_CONFIG

    for i in api_config["conf"]:
        result = ""
        dist_bindir = join(import_dir, local_bin_subdir)
        resfile = join(dist_bindir, i["filename"])
        configfile = join(api_config["configpath"], api_config["configname"])

        os.makedirs(dist_bindir, exist_ok = True)

        # reset file content
        with open(resfile, 'w') as f:
            f.write("")

        ## write base templates
        for t in api_config["base_templates"]:
            with open(t, 'r') as f:
                src = f.read()
            with open(resfile, 'a') as f:
                f.write(src)

        # write main template
        with open(i['template'], 'r') as f:
            i["config"] = configfile
            src = Template(f.read())
            result = src.substitute(i)
        with open(resfile, 'a') as f:
            f.write(result)
        chmod_x(resfile)

    # self compile
    self_src = realpath(__file__)
    self_resfile = join(dist_bindir, 'ksx')
    self_content = "#!/usr/bin/env python\n"
    # add apis to self content
    with open(join(import_dir, 'apis.py'), 'r') as f:
        self_content += f.read()
    ## copy/edit self to new file
    with open(self_src, 'r') as f:
        self_content += '\n'
        self_content += f.read()
    self_content = re.sub(r'from apis import GLOBAL_API_CONFIG', '', self_content) ## do not import apis in compiled file
    self_content = re.sub(r'is_compiled.*=.*False', 'is_compiled = True', self_content)
    with open(self_resfile, 'w') as f:
        f.write(self_content)
    chmod_x(self_resfile)


def install(verbose=False):
    api_config = GLOBAL_API_CONFIG
    dist_bindir = join(import_dir, local_bin_subdir)

    ## create bin path if not exist
    os.makedirs(api_config["binpath"], exist_ok=True)

    for i in api_config["conf"]:
        origpath = join(dist_bindir, i["filename"])
        copypath = join(api_config["binpath"], i["filename"])
        if verbose:
            print("installing file {} to {}".format(i["filename"], api_config["binpath"]))
        orig = open(origpath, "r")
        copy = open(copypath, "wt")
        line = orig.read()
        copy.write(str(line))
        orig.close()
        copy.close()

        chmod_x(copypath)


def uninstall(kubepath=None, verbose=False):
    api_config = GLOBAL_API_CONFIG
    dist_bindir = join(import_dir, local_bin_subdir)

    if not kubepath:
        kubepath = join(api_config["binpath"], 'kubectl')
    kubepath = os.path.expanduser(kubepath)

    for i in api_config["conf"]:
        path = join(api_config["binpath"], i["filename"])
        try:
            os.remove(path)
            if verbose:
                print("file {} removed".format(path))
        except FileNotFoundError:
            if verbose:
                print("file {} not found. Skip".format(path))

    try:
        os.remove(kubepath)
        if verbose:
            print("file {} removed".format(kubepath))
    except FileNotFoundError:
        if verbose:
            print("file {} not found. Skip".format(kubepath))


def add_to_path(verbose=False):
    api_config = GLOBAL_API_CONFIG
    path=api_config["binpath"]

    if not search(path, os.environ.get('PATH')):
        profile_path = join(os.environ['HOME'], ".profile")
        ## try bashrc
        if not exists(profile_path):
            profile_path = join(os.environ['HOME'], ".bashrc")
            ## try zshrc
        if not exists(profile_path):
            profile_path = join(os.environ['HOME'], ".zshrc")
            ## give up
        if not exists(profile_path):
            raise FileNotFoundError("Can not find shell profile file to add ksx to PATH")
    
        with open(profile_path, 'a') as f:
            f.write("export PATH={}:$PATH\n".format(path))
        if verbose:
            print("Add {} to PATH".format(path))
    else:
        if verbose:
            print("{} already exist in PATH. Skip".format(path))


def genconfig (kubepath=None, shell='/bin/bash', verbose=False):
    api_config = GLOBAL_API_CONFIG

    # make config directory
    os.makedirs(api_config["configpath"], exist_ok = True)

    configpath = join(api_config["configpath"], api_config["configname"])
    ## set default kubepath
    if not kubepath:
        kubepath = join(api_config["binpath"], 'kubectl')
    kubepath = os.path.expanduser(kubepath)

    ## setup config file
    config = {
        "cmd": kubepath,
        "shell": shell
    }

    json_object = dumps(config, indent = 2)

    if verbose:
        print("Generating configfile {}".format(configpath))
    with open(configpath, "w") as outfile:
        outfile.write(json_object)


def run_kubectl(kubeargs="", kubepath=None, verbose=False):
    api_config = GLOBAL_API_CONFIG

    config = join(api_config["configpath"], api_config["configname"])

    if not kubepath:
        kubepath = join(api_config["binpath"], 'kubectl')
    kubepath = os.path.expanduser(kubepath)

    cmd = "{} {}".format(kubepath, kubeargs)
    subprocess.call(cmd, shell=True)
    if verbose:
        werbs = Werbs(trace=verbose)
        ns = werbs.current_namespace()
        curr_context = werbs.current_context()
        print("cmd: `{}`; namespace: `{}`; context: `{}`".format(cmd, ns, curr_context))


def show_extended_help ():
    api_config = GLOBAL_API_CONFIG
    print('''ksX is a collection of tools for kubernetes, wrapped over standard
kubernetes control tool `kubectl`.  The motivation of ksX is to
develop more `laconic` kubectl, that also follows unix way principle:
`Make each program do one thing well` and principle of least
astonishment. So, each ksX's tool is very simple and bound to some
kubernetes resouce, like `pod`, `ingress` etc. The list of ksX tools:
''')

    for i in api_config['conf']:
        print("{}\t- {}".format(i["filename"], i["description"]))


def main():
    parser = argparse.ArgumentParser(description="Service tool for ksx tools collection")

    if not is_compiled:
        parser.add_argument('--compile',
                            action='store_true',
                            dest='compile',
                            help='Compile ksx script files'
                            )

    parser.add_argument('--install',
                        action='store_true',
                        dest='install',
                        help='Install ksx script files'
                        )

    parser.add_argument('--uninstall',
                        action='store_true',
                        dest='uninstall',
                        help='Uninstall ksx script files'
                        )

    parser.add_argument('--add-to-path',
                        action='store_true',
                        dest='add_to_path',
                        help="Add ksx scripts bin directory to user's PATH"
                        )

    parser.add_argument('--kubectl-version',
                        dest='kubeversion',
                        type=str,
                        help='Install specified kubectl version (default: current stable)',
                        default=None
                        )

    parser.add_argument('--genconfig',
                        action='store_true',
                        dest='genconfig',
                        help='Generate standard ksx configfile'
                        )

    parser.add_argument('--kubectl-path',
                        dest='kubepath',
                        type=str,
                        help="Default command to exec with 'ksp -x <pod>', 'ksd -x <deployment>' etc. (default: /bin/bash)",
                        default=None
                        )

    parser.add_argument('--kubectl-defcmd',
                        dest='kubecmd',
                        type=str,
                        help="Default command to exec with 'ksp -x <pod>', 'ksd -x <deployment>' etc. (default: /bin/bash)",
                        default='/bin/bash'
                        )

    parser.add_argument("kubectl_run",
                        type=str,
                        help="Use 'ksx <r|run> [kubectl args]' to run kubectl directly with its arguments".format(__file__),
                        nargs='*')

    parser.add_argument('-v', '--verbose',
                        action='store_true',
                        dest='verbose',
                        help='Run verbose',
                        default=False
                        )

    parser.add_argument('-i', '--info',
                        action='store_true',
                        dest='info',
                        help='Print extended information about ksx tools and exit',
                        default=False
                        )


    args = parser.parse_args()

    if len(args.kubectl_run) > 0:
        if args.kubectl_run[0] == 'run' or args.kubectl_run[0] == 'r':
            args.kubectl_run.pop(0)
            print(args.kubectl_run)
            run_kubectl(kubeargs=" ".join([x for x in args.kubectl_run]))
    elif not is_compiled and args.compile:
        compile(args.verbose)
    elif args.install:
        if not is_compiled:
            compile(args.verbose)
            install(args.verbose)
        install_kubectl(kubepath=args.kubepath, kubeversion=args.kubeversion, verbose=args.verbose)
        genconfig(kubepath=args.kubepath, shell=args.kubecmd, verbose=args.verbose)
    elif args.uninstall:
        uninstall(kubepath=args.kubepath, verbose=args.verbose)
    elif args.add_to_path:
        add_to_path(args.verbose)
    elif args.genconfig:
        genconfig(kubepath=args.kubepath, shell=args.kubecmd, verbose=args.verbose)
    elif args.info:
        show_extended_help()
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
